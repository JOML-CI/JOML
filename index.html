<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>JOML by JOML-CI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">JOML</h1>
      <h2 class="project-tagline">A Java math library for OpenGL rendering calculations</h2>
      <a href="https://github.com/JOML-CI/JOML" class="btn">View on GitHub</a>
      <a href="apidocs/index.html" class="btn">View JavaDocs</a>
      <a href="https://github.com/JOML-CI/JOML/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/JOML-CI/JOML/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="design-goals" class="anchor" href="#design-goals" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Design goals</h2>

<p>The goal of JOML is to provide easy-to-use, feature-rich and efficient linear algebra operations, needed by any 3D application. At the same time, JOML tries to pose the lowest possible requirements to an execution environment by being compatible with Java 1.4 and not making use of JNI.</p>

<p>If you like to know more about JOML's design, see the corresponding <a href="https://github.com/JOML-CI/JOML/wiki/Design">Wiki page</a>.</p>

<h2>
<a id="vector-arithmetic" class="anchor" href="#vector-arithmetic" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Vector arithmetic</h2>

<p>All operations in JOML are designed to modify the object on which the operation is invoked. This helps in completely eliminating any object allocations, which the client could otherwise not control and which impact the GC performance resulting in small hickups.
The client is responsible to allocate the needed working objects.</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Vector3f</span> v <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Vector3f</span>(<span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>);
<span class="pl-smi">Vector3f</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Vector3f</span>(<span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>);
<span class="pl-c">// v = v + a</span>
v<span class="pl-k">.</span>add(a);
<span class="pl-c">// a = a x v</span>
a<span class="pl-k">.</span>cross(v);
<span class="pl-c">// a = a/|a|</span>
a<span class="pl-k">.</span>normalize();</pre></div>

<h2>
<a id="matrix-api" class="anchor" href="#matrix-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Matrix API</h2>

<p>Using JOML you can build matrices out of basic transformations, such as scale, translate and rotate, using a fluent interface style. All such operations directly modify the matrix instance on which they are invoked.
The following example builds a transformation matrix which effectively first scales all axes by 0.5
and then translates x by 2.0:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Vector3f</span> v <span class="pl-k">=</span> <span class="pl-c1">...</span>;
<span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>()<span class="pl-k">.</span>translate(<span class="pl-c1">2.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>)
              .scale(<span class="pl-c1">0.5f</span>)
              .transformPosition(v);
<span class="pl-c">// v is now transformed by the specified transformation</span></pre></div>

<p>Common transformation idioms, such as rotating about a given axis using a specific rotation center, can be expressed in a simple way. The following example rotates the point (0, 4, 4) about the x-axis and uses (0, 3, 4) as the rotation center:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Vector3f</span> center <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Vector3f</span>(<span class="pl-c1">0.0f</span>, <span class="pl-c1">3.0f</span>, <span class="pl-c1">4.0f</span>);
<span class="pl-smi">Vector3f</span> pointToRotate <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Vector3f</span>(<span class="pl-c1">0.0f</span>, <span class="pl-c1">4.0f</span>, <span class="pl-c1">4.0f</span>);
<span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>()<span class="pl-k">.</span>translate(center)
              .rotate((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">90.0f</span>), <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>)
              .translate(center<span class="pl-k">.</span>negate())
              .transformPosition(pointToRotate);</pre></div>

<p>The vector <em>pointToRotate</em> will now represent (0, 3, 5).</p>

<h2>
<a id="post-multiplication" class="anchor" href="#post-multiplication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Post-multiplication</h2>

<p>All transformation operations in the matrix and quaternion classes act in the same way as OpenGL and GLU by post-multiplying the operation's result to the object on which they are invoked. This allows to chain multiple transformations in the same way as with OpenGL's legacy matrix stack operations, and allows to decompose the resulting effective matrix as a decomposition of multiple matrix multiplications.
One such common decomposition are the <em>projection</em> and <em>modelview</em> matrices, written as: <code>P * MV</code>. The <em>modelview</em> matrix of course can be further decomposed into individual matrix multiplications, as far as this seems necessary.</p>

<p>When invoking transformation methods in JOML's matrix classes, a convenient way now is to think of Java's <em>dot</em> operator as a matrix multiplication. If multiple matrix operations are chained after one another, as shown in the above example, each individual operation/method creates its matrix which is then post-multiplied to the matrices built before.</p>

<p>In addition to the post-multiplying methods, there are still ways to set a matrix or quaternion to a given transformation regardless of what that matrix or quaternion was before:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Matrix4f</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>();
<span class="pl-smi">Vector3f</span> point <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Vector3f</span>(<span class="pl-c1">1.0f</span>, <span class="pl-c1">2.0f</span>, <span class="pl-c1">3.0f</span>);
<span class="pl-smi">Vector3f</span> offset <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Vector3f</span>(<span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>);
<span class="pl-c1">...</span>
m<span class="pl-k">.</span>translation(offset)<span class="pl-k">.</span>transformPosition(point);</pre></div>

<p>In the above example, the matrix <em>m</em> is being set to a translation, instead of applying the translation to it.
These methods are useful when the same matrix is being used in a sequence of consecutive operations or repeatedly in a loop without having to set it to the identity each time.</p>

<h2>
<a id="building-a-camera-transformation" class="anchor" href="#building-a-camera-transformation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building a camera transformation</h2>

<p>In the same way that you can concatenate multiple simple affine transformations, you can use the methods perspective(), frustum() and ortho() to specify a perspective or orthographic projection and lookAt() to create an orthonormal transformation that mimics a camera <em>looking</em> at a given point.
Those methods resemble the ones known from GLU and act in the same way (i.e. they apply their transformations to an already existing transformation):</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Matrix4f</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>()
     .perspective((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">45.0f</span>), <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.01f</span>, <span class="pl-c1">100.0f</span>)
     .lookAt(<span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">10.0f</span>,
             <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>,
             <span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>);
<span class="pl-c">// the camera transformation is now in m</span></pre></div>

<p>The above transformation can then be used as a "view-projection" matrix in a shader.</p>

<h2>
<a id="computation-result" class="anchor" href="#computation-result" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Computation result</h2>

<p>Usually, instance methods operate on the object (matrix, vector, quaternion) on which they are invoked by writing the computation result back into that object. Most of the methods however also allow to specify another destination object to write the result into. This is useful if you do not want to overwrite the original object with the computation result.
This can be useful for computing the view-projection matrix and its inverse in one go:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Matrix4f</span> viewProj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>();
<span class="pl-smi">Matrix4f</span> invViewProj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>();
viewProj<span class="pl-k">.</span>perspective((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">45.0f</span>), <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.01f</span>, <span class="pl-c1">100.0f</span>)
        .lookAt(<span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>, <span class="pl-c1">3.0f</span>,
                <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>,
                <span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>)
        .invert(invViewProj);</pre></div>

<p>The <em>invViewProj</em> matrix now contains the inverse of the <em>viewProj</em> matrix, but the latter is still intact.</p>

<h2>
<a id="using-with-lwjgl" class="anchor" href="#using-with-lwjgl" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using with <a href="https://github.com/LWJGL/lwjgl3">LWJGL</a>
</h2>

<p>JOML can be used together with LWJGL to build a transformation matrix and set it as a uniform mat4 in a shader. For this, the Matrix4f class provides a method to transfer a matrix into a Java NIO FloatBuffer, which can then be used by LWJGL when calling into OpenGL:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">FloatBuffer</span> fb <span class="pl-k">=</span> <span class="pl-smi">BufferUtils</span><span class="pl-k">.</span>createFloatBuffer(<span class="pl-c1">16</span>);
<span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>()<span class="pl-k">.</span>perspective((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">45.0f</span>), <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.01f</span>, <span class="pl-c1">100.0f</span>)
              .lookAt(<span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">10.0f</span>,
                      <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>,
                      <span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>)<span class="pl-k">.</span>get(fb);
glUniformMatrix4fv(mat4Location, <span class="pl-c1">false</span>, fb);</pre></div>

<p>The above example first creates a transformation matrix and then uploads that matrix to a uniform variable of the active shader program using the LWJGL 3 method <a href="http://javadoc.lwjgl.org/org/lwjgl/opengl/GL20.html#glUniformMatrix4fv-int-boolean-java.nio.FloatBuffer-"><em>glUniformMatrix4fv</em></a>.</p>

<p>Instead of using the uniform methods, one or multiple matrices can also be uploaded to an OpenGL buffer object and then sourced from that buffer object from within a shader when used as an uniform buffer object or a shader storage buffer object.
The following uploads a matrix to an OpenGL buffer object which can then be used as an uniform buffer object in a shader:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Matrix4f</span> m <span class="pl-k">=</span> <span class="pl-c1">...</span>; <span class="pl-c">// &lt;- the matrix to upload</span>
<span class="pl-k">int</span> ubo <span class="pl-k">=</span> <span class="pl-c1">...</span>; <span class="pl-c">// &lt;- name of a created and already initialized UBO</span>
<span class="pl-smi">FloatBuffer</span> fb <span class="pl-k">=</span> <span class="pl-smi">BufferUtils</span><span class="pl-k">.</span>createFloatBuffer(<span class="pl-c1">16</span>);
glBindBuffer(<span class="pl-c1">GL_UNIFORM_BUFFER</span>, ubo);
glBufferSubData(<span class="pl-c1">GL_UNIFORM_BUFFER</span>, <span class="pl-c1">0</span>, m<span class="pl-k">.</span>get(fb));</pre></div>

<p>If you prefer not to use shaders but the fixed-function pipeline and want to use JOML to build the transformation matrices, you can do so. Instead of uploading the matrix as a shader uniform you can then use the OpenGL API call <a href="http://javadoc.lwjgl.org/org/lwjgl/opengl/GL11.html#glLoadMatrixf-java.nio.FloatBuffer-"><em>glLoadMatrixf()</em></a> provided by LWJGL to set a JOML matrix as the current matrix in OpenGL's matrix stack:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">FloatBuffer</span> fb <span class="pl-k">=</span> <span class="pl-smi">BufferUtils</span><span class="pl-k">.</span>createFloatBuffer(<span class="pl-c1">16</span>);
<span class="pl-smi">Matrix4f</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>();
m<span class="pl-k">.</span>setPerspective((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">45.0f</span>), <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.01f</span>, <span class="pl-c1">100.0f</span>)<span class="pl-k">.</span>get(fb);
glMatrixMode(<span class="pl-c1">GL_PROJECTION</span>);
glLoadMatrixf(fb);
m<span class="pl-k">.</span>setLookAt(<span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">10.0f</span>,
            <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>,
            <span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>)<span class="pl-k">.</span>get(fb);
glMatrixMode(<span class="pl-c1">GL_MODELVIEW</span>);
glLoadMatrixf(fb);</pre></div>

<h2>
<a id="using-with-vulkan-and-lwjgl-3" class="anchor" href="#using-with-vulkan-and-lwjgl-3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using with Vulkan and LWJGL 3</h2>

<p>You can use <a href="http://javadoc.lwjgl.org/org/lwjgl/vulkan/VK10.html#vkMapMemory-org.lwjgl.vulkan.VkDevice-long-long-long-int-org.lwjgl.PointerBuffer-">VK10.vkMapMemory()</a> provided by LWJGL to map a Vulkan memory object, which may be the backing store of a Uniform Buffer, into Java and use the returned Java NIO ByteBuffer to upload the matrix like you would with OpenGL by calling <a href="http://joml-ci.github.io/JOML/apidocs/org/joml/Matrix4f.html#get-java.nio.ByteBuffer-">get()</a> on the matrix:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Matrix4f</span> m <span class="pl-k">=</span> <span class="pl-c1">...</span>;
<span class="pl-smi">VkDevice</span> device <span class="pl-k">=</span> <span class="pl-c1">...</span>; <span class="pl-c">// &lt;- the vulkan device</span>
<span class="pl-k">long</span> memory <span class="pl-k">=</span> <span class="pl-c1">...</span>; <span class="pl-c">// &lt;- handle to the vulkan device memory</span>
<span class="pl-smi">PointerBuffer</span> pb <span class="pl-k">=</span> <span class="pl-smi">MemoryUtil</span><span class="pl-k">.</span>memAllocPointer(<span class="pl-c1">1</span>);
<span class="pl-k">if</span> (vkMapMemory(device, memory, <span class="pl-c1">0</span>, <span class="pl-c1">16</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">2</span>, <span class="pl-c1">0</span>, pb) <span class="pl-k">==</span> <span class="pl-c1">VK_SUCCESS</span>) {
  m<span class="pl-k">.</span>get(<span class="pl-smi">MemoryUtil</span><span class="pl-k">.</span>memByteBuffer(pb<span class="pl-k">.</span>get(<span class="pl-c1">0</span>), <span class="pl-c1">16</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">2</span>));
  vkUnmapMemory(device, memory);
}
<span class="pl-smi">MemoryUtil</span><span class="pl-k">.</span>memFree(pb);</pre></div>

<p>Since Vulkan uses a clip space z range between <em>0 &lt;= z &lt;= w</em> you need to tell JOML about it when creating a projection matrix. For this, the projection methods on the Matrix4f class have an additional overload taking a boolean parameter to indicate whether Z should be within [0..1] like in Vulkan or [-1..+1] like in OpenGL. The existing method overload without that parameter will default to OpenGL behaviour.</p>

<p>Alternatively, you can use Vulkan's Push Constants to quickly upload a matrix in a shader push-constant when recording a command buffer. The following code updates a Matrix4f used as a push-constant in the vertex shader:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Matrix4f</span> m <span class="pl-k">=</span> <span class="pl-c1">...</span>;
<span class="pl-smi">VkCommandBuffer</span> cmdBuf <span class="pl-k">=</span> <span class="pl-c1">...</span>; <span class="pl-c">// &lt;- the VkCommandBuffer</span>
<span class="pl-k">long</span> layout <span class="pl-k">=</span> <span class="pl-c1">...</span>; <span class="pl-c">// &lt;- handle to a Vulkan VkPipelineLayout</span>
<span class="pl-smi">ByteBuffer</span> bb <span class="pl-k">=</span> <span class="pl-smi">MemoryUtil</span><span class="pl-k">.</span>memAlloc(<span class="pl-c1">16</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">2</span>);
vkCmdPushConstants(cmdBuf, layout, <span class="pl-c1">VK_SHADER_STAGE_VERTEX_BIT</span>, <span class="pl-c1">0</span>, m<span class="pl-k">.</span>get(bb));
<span class="pl-smi">MemoryUtil</span><span class="pl-k">.</span>memFree(bb);</pre></div>

<p>Also, care must be taken regarding the difference between Vulkan's viewport transformation on the one side and Direct3D's and OpenGL's different viewport transformation on the other side. Since Vulkan does not perform any inversion of the Y-axis from NDC to window coordinates, NDC space and clip space will have its +Y axis pointing downwards (with regard to the screen).
In order to account for this, you need to use a premultiplied scaling transformation that inverts the Y-axis.</p>

<p>In essence, to create a projection transformation which will work with Vulkan, use the following code:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Matrix4f</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>();
m<span class="pl-k">.</span>scale(<span class="pl-c1">1.0f</span>, <span class="pl-k">-</span><span class="pl-c1">1.0f</span>, <span class="pl-c1">1.0f</span>) <span class="pl-c">// &lt;- inversion of Y axis</span>
 .perspective((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">45.0f</span>),
               <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.01f</span>, <span class="pl-c1">100.0f</span>, <span class="pl-c1">true</span>); <span class="pl-c">// &lt;- true indicates Z in [0..1]</span></pre></div>

<h2>
<a id="using-with-jogl" class="anchor" href="#using-with-jogl" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using with <a href="http://jogamp.org/jogl/www/">JOGL</a>
</h2>

<p>JOML can be used together with JOGL to build a transformation matrix and set it as a uniform mat4 in a shader (for example as a replacement of com.jogamp.opengl.util.glsl.fixedfunc.FixedFuncUtil and com.jogamp.opengl.util.PMVMatrix to emulate the fixed pipeline). For this, the Matrix4f class provides a method to transfer a matrix into a Java NIO FloatBuffer, which can then be used by JOGL when calling into OpenGL:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">FloatBuffer</span> fb <span class="pl-k">=</span> <span class="pl-smi">Buffers</span><span class="pl-k">.</span>newDirectFloatBuffer(<span class="pl-c1">16</span>);
<span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>()<span class="pl-k">.</span>perspective((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">45.0f</span>), <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.01f</span>, <span class="pl-c1">100.0f</span>)
              .lookAt(<span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">10.0f</span>,
                      <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>,
                      <span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>)<span class="pl-k">.</span>get(fb);
gl<span class="pl-k">.</span>glUniformMatrix4fv(mat4Location, <span class="pl-c1">1</span>, <span class="pl-c1">false</span>, fb);</pre></div>

<p>The above example first creates a transformation matrix and then uploads that matrix to a uniform variable of the active shader program using the JOGL 2 method <a href="http://jogamp.org/deployment/jogamp-next/javadoc/jogl/javadoc/com/jogamp/opengl/GL2ES2.html#glUniformMatrix4fv(int,%20int,%20boolean,%20java.nio.FloatBuffer)"><em>glUniformMatrix4fv</em></a>.</p>

<p>If you prefer not to use shaders but the fixed-function pipeline and want to use JOML to build the transformation matrices, you can do so. Instead of uploading the matrix as a shader uniform you can then use the OpenGL API call <a href="http://jogamp.org/deployment/jogamp-next/javadoc/jogl/javadoc/com/jogamp/opengl/fixedfunc/GLMatrixFunc.html#glLoadMatrixf(java.nio.FloatBuffer)"><em>glLoadMatrixf()</em></a> provided by JOGL to set a JOML matrix as the current matrix in OpenGL's matrix stack:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">FloatBuffer</span> fb <span class="pl-k">=</span> <span class="pl-smi">Buffers</span><span class="pl-k">.</span>newDirectFloatBuffer(<span class="pl-c1">16</span>);
<span class="pl-smi">Matrix4f</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>();
m<span class="pl-k">.</span>setPerspective((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">45.0f</span>), <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.01f</span>, <span class="pl-c1">100.0f</span>)<span class="pl-k">.</span>get(fb);
gl<span class="pl-k">.</span>glMatrixMode(<span class="pl-smi">GLMatrixFunc</span><span class="pl-c1"><span class="pl-k">.</span>GL_PROJECTION</span>);
gl<span class="pl-k">.</span>glLoadMatrixf(fb);
m<span class="pl-k">.</span>setLookAt(<span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">10.0f</span>,
            <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>,
            <span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>)<span class="pl-k">.</span>get(fb);
gl<span class="pl-k">.</span>glMatrixMode(<span class="pl-smi">GLMatrixFunc</span><span class="pl-c1"><span class="pl-k">.</span>GL_MODELVIEW</span>);
gl<span class="pl-k">.</span>glLoadMatrixf(fb);</pre></div>

<h2>
<a id="staying-allocation-free" class="anchor" href="#staying-allocation-free" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Staying allocation-free</h2>

<p>JOML is designed to be completely allocation-free for all methods. That means JOML will never allocate Java objects on the heap unless you as the client specifically requests to do so via the <em>new</em> keyword when creating a new matrix or vector or calling the <em>toString()</em> method on them.</p>

<p><em>JOML also does not allocate any unexpected internal helper/temporary/working objects itself, neither in instance nor static fields, thus giving you full control over object allocations.</em></p>

<p>Since you have to create a matrix or a vector at some point in order to make any computations with JOML on them, you are advised to do so once at the initialization of your program. Those objects will then be the <em>working memory/objects</em> for JOML. These working objects can then be reused in the hot path of your application without incurring any additional allocations. The following example shows a typical usecase with LWJGL:</p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">FloatBuffer</span> fb;
<span class="pl-smi">Matrix4f</span> m;

<span class="pl-k">void</span> init() {
  fb <span class="pl-k">=</span> <span class="pl-smi">BufferUtils</span><span class="pl-k">.</span>createFloatBuffer(<span class="pl-c1">16</span>);
  m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Matrix4f</span>();
  <span class="pl-c1">...</span>
}

<span class="pl-k">void</span> frame() {
  <span class="pl-c1">...</span>
  <span class="pl-c">// compute view-projection matrix</span>
  m<span class="pl-k">.</span>identity()
   .perspective((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">45.0f</span>), (<span class="pl-k">float</span>)width<span class="pl-k">/</span>height, <span class="pl-c1">0.01f</span>, <span class="pl-c1">100.0f</span>)
   .lookAt(<span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">10.0f</span>,
           <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>,
           <span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>, <span class="pl-c1">0.0f</span>);
  <span class="pl-c">// possibly apply more model transformations</span>
  m<span class="pl-k">.</span>rotateY(angle);
  <span class="pl-c">// get matrix into FloatBuffer and upload to OpenGL</span>
  m<span class="pl-k">.</span>get(fb);
  glUniformMatrix4fv(mat4Location, <span class="pl-c1">false</span>, fb);
  <span class="pl-c1">...</span>
}</pre></div>

<p>In the example above, a single Matrix4f is allocated during some initialization time when the <em>init()</em> method is called. Then each <em>frame()</em> we reinitialize the same matrix with the <em>identity()</em> and recompute the camera transformation based on some other parameters.</p>

<h2>
<a id="multithreading" class="anchor" href="#multithreading" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multithreading</h2>

<p>Due to JOML not using any internal temporary objects during any computations, you can use JOML in a multithreaded application. You only need to make sure not to call a method modifying the same matrix or vector from two different threads. Other than that, there is no internal or external synchronization necessary.</p>

<h2>
<a id="matrix-stack" class="anchor" href="#matrix-stack" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Matrix stack</h2>

<p>JOML also features an interface that resembles the matrix stack from legacy OpenGL.
This allows you to use all of the legacy OpenGL matrix stack operations even in modern OpenGL applications,
but without the otherwise necessary JNI calls into the graphics driver.
<em>Note that JOML does not interface in any way with the OpenGL API. It merely provides matrix and vector arithmetics.</em></p>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">MatrixStackf</span> s <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MatrixStackf</span>(<span class="pl-c1">2</span>);
s<span class="pl-k">.</span>translate(<span class="pl-c1">2.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>);
s<span class="pl-k">.</span>pushMatrix();
{
  s<span class="pl-k">.</span>scale(<span class="pl-c1">0.5f</span>, <span class="pl-c1">0.5f</span>, <span class="pl-c1">0.5f</span>);
  <span class="pl-c">// do something with the Matrix4f of 's'</span>
}
s<span class="pl-k">.</span>popMatrix();
s<span class="pl-k">.</span>rotate((<span class="pl-k">float</span>) <span class="pl-smi">Math</span><span class="pl-k">.</span>toRadians(<span class="pl-c1">45.0f</span>), <span class="pl-c1">0.0f</span>, <span class="pl-c1">0.0f</span>, <span class="pl-c1">1.0f</span>);
<span class="pl-c">// do something with the Matrix4f of 's'</span></pre></div>

<h2>
<a id="projects-using-joml" class="anchor" href="#projects-using-joml" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Projects and Organisations using JOML</h2>

<p>This section names real-world projects and organisations using JOML. All owners of the projects and responsible contacts of an organisation listed here were asked for permission before.</p>

<ul>
<li>
<a href="http://www.weshallwake.com/2015/09/we-shall-wake-post-demo-7-briefing.html">We Shall Wake</a> â€“ Post-World Accelerated Action.</li>
<li>
<a href="http://www.cs.unh.edu/~cs770/">Computer Graphics course</a> at the University of New Hampshire</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/JOML-CI/JOML">JOML</a> is maintained by <a href="https://github.com/JOML-CI">JOML-CI</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
